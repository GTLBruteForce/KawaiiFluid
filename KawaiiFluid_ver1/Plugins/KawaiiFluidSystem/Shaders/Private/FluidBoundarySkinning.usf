// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Boundary Particle Skinning
// Transforms bone-local boundary particles to world space using bone transforms

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

#define THREAD_GROUP_SIZE 256

//=============================================================================
// Structures (must match C++ FGPUBoundaryParticleLocal and FGPUBoundaryParticle)
//=============================================================================

struct FGPUBoundaryParticleLocal
{
	float3 LocalPosition;   // Bone-local position
	int BoneIndex;          // Skeleton bone index (-1 for static mesh)
	float3 LocalNormal;     // Bone-local surface normal
	float Psi;              // Volume contribution
};

struct FGPUBoundaryParticle
{
	float3 Position;        // World position
	float Psi;              // Volume contribution
	float3 Normal;          // World normal
	int OwnerID;            // Owner component ID
	float3 Velocity;        // World velocity (for moving boundaries)
	float Padding;          // Alignment padding
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Input: Local boundary particles (persistent, uploaded once)
StructuredBuffer<FGPUBoundaryParticleLocal> LocalBoundaryParticles;

// Output: World-space boundary particles (updated each frame)
RWStructuredBuffer<FGPUBoundaryParticle> WorldBoundaryParticles;

// Previous frame positions for velocity calculation
StructuredBuffer<FGPUBoundaryParticle> PreviousWorldBoundaryParticles;

// Bone transforms (uploaded each frame) - 4x3 matrix packed as 3 float4
// [Row0.xyz, Row1.x] [Row1.yz, Row2.xy] [Row2.z, Translation.xyz]
// Using float4x4 for simplicity - only first 3 rows used
StructuredBuffer<float4x4> BoneTransforms;

int BoundaryParticleCount;
int BoneCount;
int OwnerID;
int bHasPreviousFrame;  // 1 if previous frame data is valid, 0 otherwise

// Fallback transform for static meshes (BoneIndex == -1)
float4x4 ComponentTransform;

// Delta time for velocity calculation
float DeltaTime;

//=============================================================================
// Main Skinning Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundarySkinningCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)BoundaryParticleCount)
	{
		return;
	}

	FGPUBoundaryParticleLocal local = LocalBoundaryParticles[idx];

	float4x4 transform;

	if (local.BoneIndex >= 0 && local.BoneIndex < BoneCount)
	{
		// Skeletal mesh: use bone transform
		transform = BoneTransforms[local.BoneIndex];
	}
	else
	{
		// Static mesh or invalid bone: use component transform
		transform = ComponentTransform;
	}

	// Transform position: WorldPos = LocalPos * Transform (row-major, Unreal convention)
	float4 localPos4 = float4(local.LocalPosition, 1.0f);
	float3 worldPos = mul(localPos4, transform).xyz;

	// Transform normal (rotation only, no translation)
	float3x3 rotationMatrix = (float3x3)transform;
	float3 worldNormal = normalize(mul(local.LocalNormal, rotationMatrix));

	// Calculate velocity from position difference
	float3 velocity = float3(0, 0, 0);
	if (bHasPreviousFrame && DeltaTime > 0.0001f)
	{
		float3 prevPos = PreviousWorldBoundaryParticles[idx].Position;
		velocity = (worldPos - prevPos) / DeltaTime;
	}

	// Write output
	FGPUBoundaryParticle output;
	output.Position = worldPos;
	output.Psi = local.Psi;
	output.Normal = worldNormal;
	output.OwnerID = OwnerID;
	output.Velocity = velocity;
	output.Padding = 0.0f;

	WorldBoundaryParticles[idx] = output;
}
