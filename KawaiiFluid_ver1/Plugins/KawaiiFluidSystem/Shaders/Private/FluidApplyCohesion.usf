// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Apply Cohesion Pass
// Applies surface tension / cohesion forces between particles (Akinci 2013)

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
StructuredBuffer<uint> CellCounts;
StructuredBuffer<uint> ParticleIndices;

int ParticleCount;
float SmoothingRadius;
float CohesionStrength;
float CellSize;

//=============================================================================
// Main Compute Shader
// Note: CohesionKernel is defined in FluidGPUPhysics.ush (Akinci 2013)
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyCohesionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	// Skip if cohesion is disabled
	if (CohesionStrength <= 0.0f)
	{
		return;
	}

	float3 pos = particle.PredictedPosition;

	// IMPORTANT: Convert smoothing radius from cm to m for kernel calculations
	float h = SmoothingRadius * CM_TO_M;

	// Cohesion force accumulator
	float3 cohesionForce = float3(0.0f, 0.0f, 0.0f);

	// Get cell coordinate for this particle (use cm for spatial hash)
	int3 centerCell = WorldToCell(pos, CellSize);
	int cellRadius = (int)ceil(SmoothingRadius / CellSize);

	// Iterate over neighboring cells
	for (int dz = -cellRadius; dz <= cellRadius; ++dz)
	{
		for (int dy = -cellRadius; dy <= cellRadius; ++dy)
		{
			for (int dx = -cellRadius; dx <= cellRadius; ++dx)
			{
				int3 neighborCell = centerCell + int3(dx, dy, dz);
				uint hash = HashCell(neighborCell);
				uint count = min(CellCounts[hash], (uint)MAX_PARTICLES_PER_CELL);
				uint startIdx = hash * MAX_PARTICLES_PER_CELL;

				for (uint i = 0; i < count; ++i)
				{
					uint neighborIdx = ParticleIndices[startIdx + i];

					// Skip self and invalid indices
					if (neighborIdx == idx || neighborIdx >= (uint)ParticleCount)
					{
						continue;
					}

					FGPUFluidParticle neighbor = Particles[neighborIdx];

					// Skip attached neighbors
					if (HasFlag(neighbor.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
					{
						continue;
					}

					float3 neighborPos = neighbor.PredictedPosition;
					float3 r_cm = pos - neighborPos;           // Distance vector in cm
					float dist_cm = length(r_cm);              // Distance in cm

					// Skip if too close or too far
					if (dist_cm < SMALL_NUMBER || dist_cm > SmoothingRadius)
					{
						continue;
					}

					// Convert to meters for kernel calculation
					float dist_m = dist_cm * CM_TO_M;

					// Cohesion kernel weight
					float cohesionWeight = CohesionKernel(dist_m, h);

					if (cohesionWeight > SMALL_NUMBER)
					{
						// Direction toward neighbor (cohesion pulls particles together)
						float3 direction = -r_cm / dist_cm;

						// Accumulate cohesion force
						cohesionForce += CohesionStrength * cohesionWeight * direction;
					}
				}
			}
		}
	}

	// Apply cohesion force to velocity
	particle.Velocity += cohesionForce;

	Particles[idx] = particle;
}
