// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Finalize Positions Pass
// Updates positions from predictions and recalculates velocities

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float DeltaTime;
float VelocityDamping;  // Velocity damping factor (0.98-0.99 typical)
float MaxVelocity;      // Safety clamp to prevent divergence

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void FinalizePositionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		// For attached particles, just sync position
		particle.Position = particle.PredictedPosition;
		Particles[idx] = particle;
		return;
	}

	// Store old position for velocity calculation
	float3 oldPosition = particle.Position;

	// Finalize position
	particle.Position = particle.PredictedPosition;

	// Recalculate velocity from position change
	// v = (x_new - x_old) / dt
	float invDt = 1.0f / max(DeltaTime, 0.0001f);
	float3 pbfVelocity = (particle.Position - oldPosition) * invDt;

	// Blend between current velocity (from constraint solving) and PBF velocity
	// This helps preserve momentum while respecting constraint corrections
	const float BlendFactor = 0.8f;  // 0.8 = 80% PBF, 20% previous velocity
	particle.Velocity = lerp(particle.Velocity, pbfVelocity, BlendFactor);

	// Apply velocity damping
	particle.Velocity *= VelocityDamping;

	// Safety clamp: prevent extreme velocities that could cause divergence
	float velocityMag = length(particle.Velocity);
	if (velocityMag > MaxVelocity)
	{
		particle.Velocity = (particle.Velocity / velocityMag) * MaxVelocity;
	}

	// Clear frame-specific flags
	particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);

	Particles[idx] = particle;
}
