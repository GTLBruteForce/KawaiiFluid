#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float4 AbsorptionColorCoefficients;  // RGB별 흡수 계수 (Beer's Law)
float SpecularStrength;
float SpecularRoughness;
float4 EnvironmentLightColor;

// Lighting Scale Parameters
float AmbientScale;
float TransmittanceScale;
float AlphaThicknessScale;
float RefractionScale;
float FresnelReflectionBlend;

// Subsurface Scattering (SSS)
float SSSIntensity;
float4 SSSColor;

// Reflection Cubemap
TextureCube ReflectionCubemap;
SamplerState ReflectionCubemapSampler;
float ReflectionIntensity;
float ReflectionMipLevel;
int bUseReflectionCubemap;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// 배경 깊이 기준값 (너무 먼 곳은 유체 없음)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Screen UV와 Linear Depth를 이용해 View Space Position 복원
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	// Clip Space 좌표 (Z는 0.5 등 임의값)
	float4 ClipPosition = float4(ScreenUV * 2.0 - 1.0, 0.5, 1.0);

	// View Space로 역투영
	float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
	ViewPosition /= ViewPosition.w;

	// 카메라에서 픽셀 방향 벡터
	float3 ViewRay = ViewPosition.xyz / ViewPosition.z;

	// LinearDepth는 보통 양수(거리)이므로 음수(-Z)로 변환
	return ViewRay * (-LinearDepth);
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;

	// 1. Fluid Depth 샘플링 (Linear Depth라고 가정)
	float FluidDepth = FluidDepthTexture.Sample(InputSampler, UV);

	// 유체가 없는 곳(배경) 처리
	// FluidDepth를 초기화할 때 아주 큰 값(예: 3.4e38)으로 했는지 확인 필요
	if (FluidDepth > BACKGROUND_DEPTH_THRESH)
	{
		discard; // 혹은 return float4(0,0,0,0);
		return;
	}

	// 2. Scene Depth 가져오기 (DeviceZ -> Linear)
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, UV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// 3. Occlusion Test (가려짐 처리)
	// FluidDepth와 SceneLinearDepth의 오차가 있을 수 있으므로 여유값(Bias)을 둠
	if (FluidDepth > SceneLinearDepth + 2.0f)
	{
		discard;
		return;
	}

	// 4. Fluid 속성 샘플링
	float3 Normal = FluidNormalTexture.Sample(InputSampler, UV).xyz;
	float Thickness = FluidThicknessTexture.Sample(InputSampler, UV).r;

	// Normal validation with proper NaN/Inf check
	// Note: length(NaN) returns NaN, and NaN < 0.1f is always false
	// So we must explicitly check for NaN/Inf before length comparison
	bool bInvalidNormal = any(isnan(Normal)) || any(isinf(Normal)) || length(Normal) < 0.1f;
	if (bInvalidNormal)
	{
		// Default to view-facing normal (View space: camera looks down -Z)
		Normal = float3(0, 0, 1);
	}

	// 5. 조명 계산 준비
	float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
	float3 ViewDir = normalize(-ViewPos); // 카메라를 향하는 벡터

	// A. Fresnel (Schlick's approximation with IOR-based F0)
	// ========================================================================
	// IOR → F0 자동 계산: F0 = ((1 - n) / (1 + n))^2
	// 물(IOR=1.33): F0 ≈ 0.02, 유리(IOR=1.5): F0 ≈ 0.04
	// FresnelStrength는 추가 배율로 사용 (1.0 = 물리적 정확)
	// ========================================================================
	float NoV = saturate(dot(Normal, ViewDir));
	float IOR_F0 = pow((1.0 - RefractiveIndex) / (1.0 + RefractiveIndex), 2.0);
	float F0 = IOR_F0 * FresnelStrength;
	float Fresnel = F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);

	// B. Diffuse + Specular (Phong Shading) - 씬의 실제 Directional Light 사용
	float3 LightDir = normalize(-View.DirectionalLightDirection);
	float3 LightColor = View.DirectionalLightColor.rgb;

	// Diffuse (Lambert)
	float NoL = saturate(dot(Normal, LightDir));
	float3 DiffuseLighting = NoL * LightColor;

	// Ambient (환경광 - 완전히 어두운 면 방지)
	float3 AmbientColor = EnvironmentLightColor.rgb * AmbientScale;

	// Total Lighting
	float3 TotalLighting = DiffuseLighting + AmbientColor;

	// Specular (Blinn-Phong)
	float3 HalfDir = normalize(LightDir + ViewDir);
	float NoH = saturate(dot(Normal, HalfDir));

	// Roughness를 Shininess로 변환 (작은 roughness = 큰 shininess = 날카로운 하이라이트)
	float Shininess = (1.0 - SpecularRoughness) * 128.0;
	float3 Specular = pow(NoH, Shininess) * SpecularStrength * LightColor;

	// C. Subsurface Scattering (SSS) - Jelly Effect
	// ========================================================================
	// Rim-based SSS: 가장자리(NoV가 작은 곳)에서 빛이 내부를 투과해 나오는 효과
	// - RimFactor: 가장자리일수록 큼 (1.0 - NoV)
	// - Thickness 연동: 얇은 부분에서 더 강하게 투과
	// ========================================================================
	float RimFactor = 1.0 - NoV;
	float ThicknessSSSMask = exp(-Thickness * 0.05);  // 얇을수록 SSS 강함
	float SSSFactor = smoothstep(0.3, 1.0, RimFactor) * SSSIntensity * ThicknessSSSMask * 0.5;
	float3 SSSContribution = SSSColor.rgb * SSSFactor * LightColor;

	// ========================================================================
	// Color Compositing (Flex-style Simple Approach)
	// ========================================================================
	float3 FinalColor;

	// 1. Scene Color 샘플링 (배경색)
	float3 SceneColor = SceneColorTexture.Sample(InputSampler, UV).rgb;

	// 2. 굴절된 배경색 샘플링 (with Refraction Mask)
	// ========================================================================
	// Refraction Mask: 얇은 부분/edge에서 굴절 감소하여 과도한 왜곡 방지
	// - ThicknessMask: 얇은 부분에서 굴절 약화
	// - EdgeMask: 가장자리(Normal.z가 작은 곳)에서 굴절 약화
	// ========================================================================
	float ThicknessMask = saturate(Thickness * 0.1);  // Thickness 기반 (얇으면 작음)
	float EdgeMask = saturate(abs(Normal.z) * 2.0);   // Edge 기반 (가장자리면 작음)
	float RefractionMask = ThicknessMask * EdgeMask;

	// 굴절 오프셋 계산 (마스크 적용)
	float2 RefractOffset = Normal.xy * RefractiveIndex * RefractionScale * RefractionMask;
	float2 RefractedUV = UV + RefractOffset;
	RefractedUV = saturate(RefractedUV);

	// 굴절 UV에서 Scene Depth 체크 (유체보다 뒤에 오브젝트가 있어야 유효한 굴절)
	float RefractedSceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, RefractedUV, 0).r;
	float RefractedSceneDepth = ConvertFromDeviceZ(RefractedSceneDeviceZ);

	// 잘못된 굴절 방지: 굴절 위치의 depth가 유체보다 가까우면 원래 UV 사용
	float bValidRefraction = (RefractedSceneDepth > FluidDepth - 1.0) ? 1.0 : 0.0;
	float2 FinalRefractUV = lerp(UV, RefractedUV, bValidRefraction);

	float3 RefractedBackground = SceneColorTexture.Sample(InputSampler, FinalRefractUV).rgb;

	// 3. Beer's Law: RGB별 두께 기반 투과율 계산
	// T(λ) = exp(-σ(λ) * thickness)
	// 각 색상 채널별로 다른 흡수 계수 적용
	// 물: R을 많이 흡수 → 파랗게 보임
	// 슬라임: B를 많이 흡수 → 녹색/노란색 계열
	float3 AbsorptionRGB = AbsorptionColorCoefficients.rgb * AbsorptionCoefficient;
	float3 Transmittance = exp(-AbsorptionRGB * Thickness * TransmittanceScale);

	// 투과된 배경색 계산
	float3 TransmittedBackground = RefractedBackground * Transmittance;

	// 4. 배경과 유체색 혼합
	// 두께가 두꺼울수록 유체 고유색이 더 보임
	float OverallAbsorption = 1.0 - dot(Transmittance, float3(0.333, 0.333, 0.333));

	// FluidColor에 조명 적용 (Phong Shading의 Diffuse + Ambient)
	float3 LitFluidColor = FluidColor.rgb * TotalLighting;
	float3 BaseColor = lerp(TransmittedBackground, LitFluidColor, saturate(OverallAbsorption));

	// 5. Fresnel 반사 (환경 반사)
	float3 ReflectedColor;
	if (bUseReflectionCubemap > 0)
	{
		// Reflection Vector 계산 (View Space Normal → World Space Reflection)
		float3 ViewSpaceReflect = reflect(-ViewDir, Normal);

		// View Space → World Space 변환 (View Matrix의 역변환)
		// ViewMatrix는 World→View 변환이므로, transpose하면 View→World (직교행렬)
		float3x3 ViewToWorld = transpose((float3x3)ViewMatrix);
		float3 WorldReflect = mul(ViewSpaceReflect, ViewToWorld);

		// Cubemap 샘플링 (Mip level로 블러 조절)
		float MipLevel = ReflectionMipLevel + SpecularRoughness * 6.0;  // Roughness 연동
		float3 CubemapColor = ReflectionCubemap.SampleLevel(ReflectionCubemapSampler, WorldReflect, MipLevel).rgb;

		ReflectedColor = CubemapColor * ReflectionIntensity * Fresnel;
	}
	else
	{
		// Fallback: 상수 환경광 색상
		ReflectedColor = EnvironmentLightColor.rgb * Fresnel;
	}

	// 6. 반사와 투과 혼합
	BaseColor = lerp(BaseColor, ReflectedColor, Fresnel * FresnelReflectionBlend);

	// 7. Specular + SSS 추가
	FinalColor = BaseColor + Specular + SSSContribution;

	// 8. Alpha 계산
	// 두께가 있으면 불투명, 반사가 강하면 불투명
	float Alpha = saturate(1.0 - exp(-Thickness * AlphaThicknessScale));
	Alpha = max(Alpha, Fresnel * FresnelReflectionBlend);

	// C++ BlendState: (SrcAlpha, InvSrcAlpha) 사용 중이므로
	// RGB에 Alpha를 미리 곱하지 않고 내보냄
	OutColor = float4(FinalColor, Alpha);
}
