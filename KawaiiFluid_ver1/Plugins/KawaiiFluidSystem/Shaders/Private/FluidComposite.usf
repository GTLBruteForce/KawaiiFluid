#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> SceneDepthTexture;
Texture2D<float4> SceneColorTexture;

SamplerState InputSampler;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float SpecularStrength;
float SpecularRoughness;
float4 EnvironmentLightColor;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
	float4 Position : SV_POSITION;
	float2 UV : TEXCOORD0;
};

void MainVS(
	in uint VertexID : SV_VertexID,
	out FCompositeVSToPS Output
)
{
	// Fullscreen Triangle
	float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
	Output.UV = UV;
	Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// 배경 깊이 기준값 (너무 먼 곳은 유체 없음)
#define BACKGROUND_DEPTH_THRESH 100000.0f

/**
 * Screen UV와 Linear Depth를 이용해 View Space Position 복원
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
	// Clip Space 좌표 (Z는 0.5 등 임의값)
	float4 ClipPosition = float4(ScreenUV * 2.0 - 1.0, 0.5, 1.0);

	// View Space로 역투영
	float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
	ViewPosition /= ViewPosition.w;

	// 카메라에서 픽셀 방향 벡터
	float3 ViewRay = ViewPosition.xyz / ViewPosition.z;

	// LinearDepth는 보통 양수(거리)이므로 음수(-Z)로 변환
	return ViewRay * (-LinearDepth);
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
	FCompositeVSToPS Input,
	out float4 OutColor : SV_Target0)
{
	float2 UV = Input.UV;

	// 1. Fluid Depth 샘플링 (Linear Depth라고 가정)
	float FluidDepth = FluidDepthTexture.Sample(InputSampler, UV);

	// 유체가 없는 곳(배경) 처리
	// FluidDepth를 초기화할 때 아주 큰 값(예: 3.4e38)으로 했는지 확인 필요
	if (FluidDepth > BACKGROUND_DEPTH_THRESH)
	{
		discard; // 혹은 return float4(0,0,0,0);
		return;
	}

	// 2. Scene Depth 가져오기 (DeviceZ -> Linear)
	float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, UV, 0).r;
	float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ);

	// 3. Occlusion Test (가려짐 처리)
	// FluidDepth와 SceneLinearDepth의 오차가 있을 수 있으므로 여유값(Bias)을 둠
	if (FluidDepth > SceneLinearDepth + 2.0f)
	{
		discard;
		return;
	}

	// 4. Fluid 속성 샘플링
	float3 Normal = FluidNormalTexture.Sample(InputSampler, UV).xyz;
	float Thickness = FluidThicknessTexture.Sample(InputSampler, UV).r;

	// Normal이 (0,0,0)인 경우 방어 코드 (혹시 모를 에러 방지)
	if (length(Normal) < 0.1f)
	{
		Normal = float3(0, 0, 1);
	}

	// 5. 조명 계산 준비
	float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
	float3 ViewDir = normalize(-ViewPos); // 카메라를 향하는 벡터

	// A. Fresnel (반사율, Schlick's approximation 사용)
	float NoV = saturate(dot(Normal, ViewDir));
	float F0 = FresnelStrength;
	float Fresnel = F0 + (1.0 - F0) * pow(1.0 - NoV, 5.0);

	// B. Specular (하이라이트) - 씬의 실제 Directional Light 사용
	float3 LightDir = normalize(-View.DirectionalLightDirection);
	float3 HalfDir = normalize(LightDir + ViewDir);
	float NoH = saturate(dot(Normal, HalfDir));

	// Roughness를 Shininess로 변환 (작은 roughness = 큰 shininess = 날카로운 하이라이트)
	float Shininess = (1.0 - SpecularRoughness) * 128.0;
	float Specular = pow(NoH, Shininess) * SpecularStrength;

	// ========================================================================
	// Color Compositing (Flex-style Simple Approach)
	// ========================================================================
	float3 FinalColor;

	// 1. Scene Color 샘플링 (배경색)
	float3 SceneColor = SceneColorTexture.Sample(InputSampler, UV).rgb;

	// 2. 굴절된 배경색 샘플링
	float2 RefractedUV = UV + Normal.xy * RefractiveIndex * 0.05;
	RefractedUV = saturate(RefractedUV);
	float3 RefractedBackground = SceneColorTexture.Sample(InputSampler, RefractedUV).rgb;

	// 3. Beer's Law: 두께에 따른 투과율 (단순 지수 감쇠)
	// 얇은 부분 = 높은 투과율 (배경색 많이 보임 → 하늘색/흰색 계열)
	// 두꺼운 부분 = 낮은 투과율 (유체색 많이 보임 → 진한 파란색)
	float AbsorptionFactor = 1.0 - exp(-Thickness * AbsorptionCoefficient * 0.05);

	// 4. 배경과 유체색 혼합
	// AbsorptionFactor가 0 (얇음) → 배경색 그대로
	// AbsorptionFactor가 1 (두꺼움) → 유체색
	float3 BaseColor = lerp(RefractedBackground, FluidColor.rgb, AbsorptionFactor);

	// 5. Fresnel 반사 (환경광 반사)
	// SceneColor 대신 별도의 밝은 Environment Light 사용
	float3 ReflectedColor = EnvironmentLightColor.rgb * Fresnel;

	// 6. 반사와 투과 혼합
	BaseColor = lerp(BaseColor, ReflectedColor, Fresnel * 0.5);

	// 7. Specular 추가
	FinalColor = BaseColor + Specular;

	// 7. Alpha 계산
	// 두께가 있으면 불투명, 반사가 강하면 불투명
	float Alpha = saturate(1.0 - exp(-Thickness * 0.02));
	Alpha = max(Alpha, Fresnel * 0.5);

	// C++ BlendState: (SrcAlpha, InvSrcAlpha) 사용 중이므로
	// RGB에 Alpha를 미리 곱하지 않고 내보냄
	OutColor = float4(FinalColor, Alpha);
}
