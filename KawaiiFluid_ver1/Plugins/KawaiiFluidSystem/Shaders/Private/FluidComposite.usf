#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
// #include "/Engine/Private/SceneTexturesCommon.ush" // 불필요하면 주석

// -----------------------------------------------------------------------------
// Parameters
// -----------------------------------------------------------------------------
Texture2D<float> FluidDepthTexture;
Texture2D<float4> FluidNormalTexture;
Texture2D<float> FluidThicknessTexture;
Texture2D<float> SceneDepthTexture; 

SamplerState InputSampler;

float4x4 InverseProjectionMatrix;
float4x4 ProjectionMatrix;
float4x4 ViewMatrix;

float4 FluidColor;
float FresnelStrength;
float RefractiveIndex;
float AbsorptionCoefficient;
float SpecularStrength;
float SpecularRoughness;

// -----------------------------------------------------------------------------
// Vertex Shader
// -----------------------------------------------------------------------------
struct FCompositeVSToPS
{
    float4 Position : SV_POSITION;
    float2 UV : TEXCOORD0; 
};

void MainVS(
    in uint VertexID : SV_VertexID,
    out FCompositeVSToPS Output
)
{
    // Fullscreen Triangle
    float2 UV = float2((VertexID << 1) & 2, VertexID & 2);
    Output.UV = UV;
    Output.Position = float4(UV * float2(2, -2) + float2(-1, 1), 0.5f, 1.0f);
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

// 배경 깊이 기준값 (너무 먼 곳은 유체 없음)
#define BACKGROUND_DEPTH_THRESH 100000.0f 

/**
 * Screen UV와 Linear Depth를 이용해 View Space Position 복원
 */
float3 ReconstructViewPosition(float2 ScreenUV, float LinearDepth)
{
    // Clip Space 좌표 (Z는 0.5 등 임의값)
    float4 ClipPosition = float4(ScreenUV * 2.0 - 1.0, 0.5, 1.0);

    // View Space로 역투영
    float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
    ViewPosition /= ViewPosition.w;

    // 카메라에서 픽셀 방향 벡터
    float3 ViewRay = ViewPosition.xyz / ViewPosition.z;

    // LinearDepth는 보통 양수(거리)이므로 음수(-Z)로 변환
    return ViewRay * (-LinearDepth);
}

// -----------------------------------------------------------------------------
// Pixel Shader
// -----------------------------------------------------------------------------

void MainPS(
    FCompositeVSToPS Input,
    out float4 OutColor : SV_Target0)
{
    float2 UV = Input.UV;

    // 1. Fluid Depth 샘플링 (Linear Depth라고 가정)
    float FluidDepth = FluidDepthTexture.Sample(InputSampler, UV);

    // 유체가 없는 곳(배경) 처리
    // FluidDepth를 초기화할 때 아주 큰 값(예: 3.4e38)으로 했는지 확인 필요
    if (FluidDepth > BACKGROUND_DEPTH_THRESH)
    {
        discard; // 혹은 return float4(0,0,0,0);
        return;
    }

    // 2. Scene Depth 가져오기 (DeviceZ -> Linear)
    float SceneDeviceZ = SceneDepthTexture.SampleLevel(InputSampler, UV, 0).r;
    float SceneLinearDepth = ConvertFromDeviceZ(SceneDeviceZ); // 언리얼 단위(cm)

    // 3. Occlusion Test (가려짐 처리)
    // [중요] 유체가 벽 뒤에 있으면 그리지 않음
    // *주의* FluidDepth와 SceneLinearDepth의 오차가 있을 수 있으므로 여유값(Bias)을 둠
    // 일단 화면에 나오게 하기 위해 이 부분을 주석 처리 해보셔도 좋습니다.
    if (FluidDepth > SceneLinearDepth + 2.0f) 
    {
        discard;
        return;
    }

    // 4. Fluid 속성 샘플링
    float3 Normal = FluidNormalTexture.Sample(InputSampler, UV).xyz;
    float Thickness = FluidThicknessTexture.Sample(InputSampler, UV).r;
    
    // Normal이 (0,0,0)인 경우 방어 코드 (혹시 모를 에러 방지)
    if (length(Normal) < 0.1f)
    {
        Normal = float3(0, 0, 1);
    }

    // 5. 조명 계산 준비
    float3 ViewPos = ReconstructViewPosition(UV, FluidDepth);
    float3 ViewDir = normalize(-ViewPos); // 카메라를 향하는 벡터
    
    // A. Fresnel (반사)
    float NoV = saturate(dot(Normal, ViewDir));
    float Fresnel = FresnelStrength + (1.0 - FresnelStrength) * pow(1.0 - NoV, 5.0);
    
    // B. Specular (하이라이트) - 가상 조명
    float3 LightDir = normalize(float3(0.5, 0.5, 1.0)); 
    float3 HalfDir = normalize(LightDir + ViewDir);
    float NoH = saturate(dot(Normal, HalfDir));
    float Specular = pow(NoH, SpecularRoughness) * SpecularStrength;
    
    // C. Transmittance (투과 / Beer's Law)
    // Thickness가 0이면 Transmittance는 1(투명)이 됨
    float3 Transmittance = exp(-AbsorptionCoefficient * Thickness * (1.0 - FluidColor.rgb));
    
    // 6. 최종 컬러 합성
    float3 BaseColor = FluidColor.rgb * Transmittance;
    float3 FinalColor = BaseColor + Specular; // Specular는 더하기
    
    // 7. Alpha 계산
    // 두께가 있으면 불투명, 반사가 강하면 불투명
    float Alpha = saturate(1.0 - exp(-Thickness * 0.5)); 
    Alpha = max(Alpha, Fresnel); 
    
    // [안전장치] Alpha가 너무 작으면 안 보일 수 있으니 최소값 보정 (디버깅용)
    // Alpha = max(Alpha, 0.2f); 

    // C++ BlendState: (SrcAlpha, InvSrcAlpha) 사용 중이므로
    // RGB에 Alpha를 미리 곱하지 않고 내보냅니다.
    OutColor = float4(FinalColor, Alpha);
}