// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Private/Common.ush"

// IO Resources
Texture2D InputTexture;
SamplerState InputSampler;
RWTexture2D<float> OutputTexture;

// Blur Params
float2 TextureSize;
float2 InverseTextureSize;
int2 BlurDirection; // 가로: (1, 0), 세로: (0, 1)
float BlurRadius;
float BlurDepthFalloff;

// 가우시안 가중치 계산 함수
float GetGaussianWeight(float Distance, float Sigma)
{
	float Exponent = -(Distance * Distance) / (2.0 * Sigma * Sigma);
	return exp(Exponent);
}

//=============================================================================
// Bilateral Blur
//=============================================================================

#define THREADGROUP_SIZE 8

[numthreads(THREADGROUP_SIZE, THREADGROUP_SIZE, 1)]
void BilateralBlurCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	// 유효 범위 검사
	if (any(DispatchThreadId.xy >= uint2(TextureSize)))
	{
		return;
	}

	// 현재 픽셀의 UV 좌표
	float2 CurrentUV = (DispatchThreadId.xy + 0.5) * InverseTextureSize;

	// 중심 픽셀의 깊이 샘플링
	float CenterDepth = InputTexture.SampleLevel(InputSampler, CurrentUV, 0).r;

	// 깊이 값이 없으면(배경), 원래 값을 출력하고 종료
	if (CenterDepth >= 1.0 || CenterDepth <= 0.0)
	{
		OutputTexture[DispatchThreadId.xy] = CenterDepth;
		return;
	}

	// 양방향 필터 파라미터 설정
	const int KernelRadius = int(BlurRadius);
	const float SpatialSigma = BlurRadius / 2.0;
	const float DepthSigma = BlurDepthFalloff;

	float TotalWeight = 0.0;
	float TotalWeightedDepth = 0.0;

	// 커널 영역 반복 수행
	for (int Offset = -KernelRadius; Offset <= KernelRadius; ++Offset)
	{
		// 샘플링할 UV 좌표 계산
		float2 SampleOffset = float2(BlurDirection) * (float)Offset * InverseTextureSize;
		float2 SampleUV = CurrentUV + SampleOffset;

		// 주변 깊이 샘플링
		float SampleDepth = InputTexture.SampleLevel(InputSampler, SampleUV, 0).r;

		// 배경 픽셀은 건너뜀
		if (SampleDepth >= 1.0 || SampleDepth <= 0.0)
		{
			continue;
		}

		// 공간적 가중치 계산 (거리에 따른 가우시안)
		float SpatialDistance = abs((float)Offset);
		float SpatialWeight = GetGaussianWeight(SpatialDistance, SpatialSigma);

		// 범위 가중치 계산 (깊이 차이에 따른 가우시안)
		float DepthDifference = abs(SampleDepth - CenterDepth);
		float RangeWeight = GetGaussianWeight(DepthDifference, DepthSigma);

		// 최종 양방향 가중치 결합
		float CombinedWeight = SpatialWeight * RangeWeight;

		// 가중치가 적용된 깊이 누적
		TotalWeightedDepth += SampleDepth * CombinedWeight;
		TotalWeight += CombinedWeight;
	}

	float FinalDepth = CenterDepth;

	// 정규화
	if (TotalWeight > 0.0)
	{
		FinalDepth = TotalWeightedDepth / TotalWeight;
	}

	// 결과 저장
	OutputTexture[DispatchThreadId.xy] = FinalDepth;
}
