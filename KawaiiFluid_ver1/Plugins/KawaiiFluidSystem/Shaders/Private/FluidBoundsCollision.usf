// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Bounds Collision Pass
// Applies AABB/OBB bounds collision with velocity response

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Shader Parameters
//=============================================================================

RWStructuredBuffer<FGPUFluidParticle> Particles;
int ParticleCount;
float ParticleRadius;

// OBB parameters
float3 BoundsCenter;
float3 BoundsExtent;
float4 BoundsRotation;  // Quaternion (x, y, z, w)
int bUseOBB;

// Legacy AABB parameters
float3 BoundsMin;
float3 BoundsMax;

// Collision response
float Restitution;
float Friction;

//=============================================================================
// Quaternion Helpers
//=============================================================================

// Rotate vector by quaternion: q * v * q^-1
float3 QuatRotateVector(float4 q, float3 v)
{
	// Optimized quaternion-vector rotation
	// q = (x, y, z, w) where w is scalar part
	float3 qv = float3(q.x, q.y, q.z);
	float qw = q.w;

	float3 t = 2.0f * cross(qv, v);
	return v + qw * t + cross(qv, t);
}

// Rotate vector by inverse (conjugate) of quaternion
float3 QuatRotateVectorInverse(float4 q, float3 v)
{
	// For unit quaternion, inverse = conjugate = (-x, -y, -z, w)
	float4 qConj = float4(-q.x, -q.y, -q.z, q.w);
	return QuatRotateVector(qConj, v);
}

//=============================================================================
// AABB Collision (Legacy)
//=============================================================================

void ApplyAABBCollision(inout float3 pos, inout float3 vel, inout uint flags)
{
	// Effective bounds considering particle radius
	float3 effectiveMin = BoundsMin + ParticleRadius;
	float3 effectiveMax = BoundsMax - ParticleRadius;

	// X axis collision
	if (pos.x < effectiveMin.x)
	{
		pos.x = effectiveMin.x;
		vel.x = -vel.x * Restitution;
		vel.yz *= (1.0f - Friction);
	}
	else if (pos.x > effectiveMax.x)
	{
		pos.x = effectiveMax.x;
		vel.x = -vel.x * Restitution;
		vel.yz *= (1.0f - Friction);
	}

	// Y axis collision
	if (pos.y < effectiveMin.y)
	{
		pos.y = effectiveMin.y;
		vel.y = -vel.y * Restitution;
		vel.xz *= (1.0f - Friction);
	}
	else if (pos.y > effectiveMax.y)
	{
		pos.y = effectiveMax.y;
		vel.y = -vel.y * Restitution;
		vel.xz *= (1.0f - Friction);
	}

	// Z axis collision (typically ground collision)
	if (pos.z < effectiveMin.z)
	{
		pos.z = effectiveMin.z;
		vel.z = -vel.z * Restitution;
		vel.xy *= (1.0f - Friction);
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
	else if (pos.z > effectiveMax.z)
	{
		pos.z = effectiveMax.z;
		vel.z = -vel.z * Restitution;
		vel.xy *= (1.0f - Friction);
	}
	else
	{
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}
}

//=============================================================================
// OBB Collision
//=============================================================================

void ApplyOBBCollision(inout float3 pos, inout float3 vel, inout uint flags)
{
	// Transform position from world space to OBB local space
	float3 localPos = QuatRotateVectorInverse(BoundsRotation, pos - BoundsCenter);
	float3 localVel = QuatRotateVectorInverse(BoundsRotation, vel);

	// Effective extents considering particle radius
	float3 effectiveExtent = BoundsExtent - ParticleRadius;
	effectiveExtent = max(effectiveExtent, float3(0.001f, 0.001f, 0.001f));  // Prevent negative

	bool collided = false;

	// X axis collision (in local space)
	if (localPos.x < -effectiveExtent.x)
	{
		localPos.x = -effectiveExtent.x;
		localVel.x = -localVel.x * Restitution;
		localVel.yz *= (1.0f - Friction);
		collided = true;
	}
	else if (localPos.x > effectiveExtent.x)
	{
		localPos.x = effectiveExtent.x;
		localVel.x = -localVel.x * Restitution;
		localVel.yz *= (1.0f - Friction);
		collided = true;
	}

	// Y axis collision (in local space)
	if (localPos.y < -effectiveExtent.y)
	{
		localPos.y = -effectiveExtent.y;
		localVel.y = -localVel.y * Restitution;
		localVel.xz *= (1.0f - Friction);
		collided = true;
	}
	else if (localPos.y > effectiveExtent.y)
	{
		localPos.y = effectiveExtent.y;
		localVel.y = -localVel.y * Restitution;
		localVel.xz *= (1.0f - Friction);
		collided = true;
	}

	// Z axis collision (in local space - typically floor/ceiling)
	if (localPos.z < -effectiveExtent.z)
	{
		localPos.z = -effectiveExtent.z;
		localVel.z = -localVel.z * Restitution;
		localVel.xy *= (1.0f - Friction);
		flags = SetFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
		collided = true;
	}
	else if (localPos.z > effectiveExtent.z)
	{
		localPos.z = effectiveExtent.z;
		localVel.z = -localVel.z * Restitution;
		localVel.xy *= (1.0f - Friction);
		collided = true;
	}
	else
	{
		flags = ClearFlag(flags, GPU_PARTICLE_FLAG_NEAR_GROUND);
	}

	// Transform back to world space
	pos = QuatRotateVector(BoundsRotation, localPos) + BoundsCenter;
	vel = QuatRotateVector(BoundsRotation, localVel);
}

//=============================================================================
// Main Compute Shader
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundsCollisionCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Skip attached particles (handled by CPU)
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_ATTACHED))
	{
		return;
	}

	float3 pos = particle.PredictedPosition;
	float3 vel = particle.Velocity;
	uint flags = particle.Flags;

	// Apply collision based on mode
	if (bUseOBB != 0)
	{
		ApplyOBBCollision(pos, vel, flags);
	}
	else
	{
		ApplyAABBCollision(pos, vel, flags);
	}

	// Update particle
	particle.PredictedPosition = pos;
	particle.Velocity = vel;
	particle.Flags = flags;

	Particles[idx] = particle;
}
