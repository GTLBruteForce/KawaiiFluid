// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Apply Per-Polygon Collision Corrections
// Applies position corrections computed by CPU Per-Polygon collision processing

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"

//=============================================================================
// Particle Correction Structure (must match FParticleCorrection in C++)
// 32 bytes, GPU-aligned
//
// Layout:
//   [0-3]   ParticleIndex (uint)
//   [4-7]   Flags (uint)
//   [8-19]  VelocityDelta (float3) - Velocity correction
//   [20-31] PositionDelta (float3) - Position correction
//=============================================================================

struct FParticleCorrection
{
	uint ParticleIndex;          // 4 bytes - Index in GPU particle buffer
	uint Flags;                  // 4 bytes - Collision flags
	float3 VelocityDelta;        // 12 bytes - Velocity correction (reflection/damping)
	float3 PositionDelta;        // 12 bytes - Position correction
};

// Correction flags
#define CORRECTION_FLAG_NONE     0
#define CORRECTION_FLAG_COLLIDED (1 << 0)
#define CORRECTION_FLAG_ATTACHED (1 << 1)
#define CORRECTION_FLAG_VELOCITY_CORRECTED (1 << 2)

//=============================================================================
// Shader Parameters
//=============================================================================

StructuredBuffer<FParticleCorrection> Corrections;
RWStructuredBuffer<FGPUFluidParticle> Particles;

uint CorrectionCount;

//=============================================================================
// Main Compute Shader - Apply Corrections
//=============================================================================

#ifndef THREAD_GROUP_SIZE
#define THREAD_GROUP_SIZE 256
#endif

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ApplyCorrectionsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= CorrectionCount)
	{
		return;
	}

	FParticleCorrection correction = Corrections[idx];
	uint particleIdx = correction.ParticleIndex;

	// Apply position correction - push particle out of surface
	Particles[particleIdx].Position += correction.PositionDelta;
	Particles[particleIdx].PredictedPosition += correction.PositionDelta;

	// Apply velocity correction - reflect velocity away from surface
	// This is critical to prevent particle from immediately re-entering the mesh
	if ((correction.Flags & CORRECTION_FLAG_VELOCITY_CORRECTED) != 0)
	{
		Particles[particleIdx].Velocity += correction.VelocityDelta;
	}

	// Update particle flags if collision occurred
	if ((correction.Flags & CORRECTION_FLAG_COLLIDED) != 0)
	{
		// Could mark particle as near surface for special rendering
	}

	// If particle should be marked as attached
	if ((correction.Flags & CORRECTION_FLAG_ATTACHED) != 0)
	{
		Particles[particleIdx].Flags |= GPU_PARTICLE_FLAG_IS_ATTACHED;
	}
}
