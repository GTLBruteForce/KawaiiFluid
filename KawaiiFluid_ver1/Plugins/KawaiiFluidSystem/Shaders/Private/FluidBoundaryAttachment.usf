// Copyright 2026 Team_Bruteforce. All Rights Reserved.
// GPU Fluid Physics - Boundary Attachment Update Pass
// Manages strong position constraints between fluid particles and boundary owners
//
// Features:
// - Attach: Fluid particles within AttachRadius of boundary particles get attached
// - Detach: When distance > threshold OR relative velocity > threshold
// - Cooldown: Prevents immediate re-attachment after detaching
// - Bone-Local Position: Attached particles stored in bone's local space (follows bone animation)
//
// Uses Z-Order neighbor search for efficient boundary particle lookup

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"
#include "FluidGPUPhysics.ush"
#include "FluidSpatialHash.ush"
#include "FluidMortonUtils.ush"

//=============================================================================
// Structures (must match C++ definitions in GPUFluidParticle.h)
//=============================================================================

struct FGPUBoundaryParticle
{
	float3 Position;      // 12 bytes - World position
	float Psi;            // 4 bytes  - Boundary particle "mass"
	float3 Normal;        // 12 bytes - Surface normal
	int OwnerID;          // 4 bytes  - Owner component ID
	float3 Velocity;      // 12 bytes - World velocity (for moving boundaries)
	float FrictionCoeff;  // 4 bytes  - Coulomb friction coefficient
	int BoneIndex;        // 4 bytes  - Skeleton bone index (-1 for static mesh)
	float3 Padding;       // 12 bytes - Alignment padding
};

// NOTE: FGPUBoundaryAttachment is now embedded in FGPUFluidParticle (96 bytes)
// See particle.AttachOwnerID, AttachBoneIndex, AttachmentTime, AttachLocalPosition, etc.
// This ensures attachment data is automatically reordered during Z-Order sorting.

// Owner Transform (128 bytes = two 4x4 matrices) - fallback for component-level transform
struct FGPUBoundaryOwnerTransform
{
	float4x4 WorldMatrix;         // 64 bytes - Local to World
	float4x4 InverseWorldMatrix;  // 64 bytes - World to Local
};

//=============================================================================
// Shader Parameters
//=============================================================================

// Fluid particles (read-write)
// NOTE: Attachment data is now embedded in FGPUFluidParticle (96 bytes)
// This ensures attachment data is automatically reordered during Z-Order sorting
RWStructuredBuffer<FGPUFluidParticle> Particles;

// Boundary particles (Z-Order sorted, read-only)
StructuredBuffer<FGPUBoundaryParticle> SortedBoundaryParticles;
StructuredBuffer<uint> BoundaryCellStart;
StructuredBuffer<uint> BoundaryCellEnd;

// Owner transforms (indexed by OwnerID) - fallback for component-level transform
StructuredBuffer<FGPUBoundaryOwnerTransform> OwnerTransforms;
int MaxOwnerID;  // Maximum valid OwnerID (for bounds checking)

// Bone transforms (uploaded each frame from skinning pass)
// float4x4 matrices indexed by BoneIndex
StructuredBuffer<float4x4> BoneTransforms;
StructuredBuffer<float4x4> InverseBoneTransforms;  // Pre-computed on CPU for accuracy (handles scale correctly)
int BoneCount;  // Number of bones in the skeleton

// Debug counters (atomic increment for diagnostics)
// [0] = Attached particle count
// [1] = Particles that found a boundary (nearestBoundaryIdx >= 0)
// [2] = Particles within AttachRadius
// [3] = Particles with valid OwnerID
// [4] = New attachments this frame
// [5] = Detachments this frame
// [6] = Particles in cooldown
// [7] = Particles already attached (maintained)
RWBuffer<uint> AttachmentCounter;

// Parameters
int ParticleCount;
int BoundaryParticleCount;
float AttachRadius;
float DetachDistanceMultiplier;
float DetachSpeedThreshold;
float AttachCooldown;
float ConstraintBlend;
float AdhesionStrength;  // Detach threshold = AdhesionStrength * 10
float CurrentTime;
float DeltaTime;
float SmoothingRadius;
float CellSize;

// Z-Order bounds
float3 MortonBoundsMin;

//=============================================================================
// Transform Utilities
//=============================================================================

float3 TransformPosition(float3 localPos, float4x4 worldMatrix)
{
	float4 worldPos = mul(float4(localPos, 1.0f), worldMatrix);
	return worldPos.xyz;
}

float3 InverseTransformPosition(float3 worldPos, float4x4 inverseWorldMatrix)
{
	float4 localPos = mul(float4(worldPos, 1.0f), inverseWorldMatrix);
	return localPos.xyz;
}

float3 TransformDirection(float3 localDir, float4x4 worldMatrix)
{
	float4 worldDir = mul(float4(localDir, 0.0f), worldMatrix);
	return normalize(worldDir.xyz);
}

float3 InverseTransformDirection(float3 worldDir, float4x4 inverseWorldMatrix)
{
	float4 localDir = mul(float4(worldDir, 0.0f), inverseWorldMatrix);
	return normalize(localDir.xyz);
}

//=============================================================================
// Z-Order Cell ID Calculation
//=============================================================================

uint GetMortonCellIDFromCellCoord_Attach(int3 cellCoord)
{
	int3 gridMin = int3(floor(MortonBoundsMin / CellSize));
	int3 offset = cellCoord - gridMin;
	uint3 uoffset = uint3(max(offset, int3(0, 0, 0)));
	uoffset = min(uoffset, uint3(MORTON_MAX_VALUE, MORTON_MAX_VALUE, MORTON_MAX_VALUE));
	return Morton3D(uoffset.x, uoffset.y, uoffset.z);
}

//=============================================================================
// Find Nearest Boundary Particle using Z-Order Search
// Returns: boundary index, or -1 if none within AttachRadius
// Also outputs the OwnerID for local space conversion
//=============================================================================

// Debug counters for FindNearestBoundaryParticle
// [8] = Total cells searched
// [9] = Non-empty cells found
// [10] = Boundary particles checked
// [11] = Particles with distance < AttachRadius^2 (pure distance check)
// [12] = Particles with valid OwnerID (0 <= OwnerID <= MaxOwnerID)
// [13] = Minimum distance squared found (as uint bits)
// [14] = First boundary OwnerID found (for debugging)
// [15] = Count of OwnerID == -1

int FindNearestBoundaryParticle(float3 pos, out float outDistance, out int outOwnerID, out int outBoneIndex, out float3 outWorldNormal, out float3 outBoundaryVelocity)
{
	int nearestIdx = -1;
	float nearestDistSq = AttachRadius * AttachRadius;
	int nearestOwnerID = -1;
	int nearestBoneIndex = -1;
	float3 nearestNormal = float3(0, 0, 1);
	float3 nearestVelocity = float3(0, 0, 0);

	int3 centerCell = WorldToCell(pos, CellSize);
	int cellRadius = (int)ceil(AttachRadius / CellSize);

	uint localCellsSearched = 0;
	uint localNonEmptyCells = 0;
	uint localBoundaryChecked = 0;
	uint localWithinRadius = 0;
	uint localValidOwner = 0;
	uint localOwnerNegOne = 0;
	float localMinDistSq = 1e20f;
	int localFirstOwnerID = -999;

	// Search neighboring cells
	for (int dz = -cellRadius; dz <= cellRadius; ++dz)
	{
		for (int dy = -cellRadius; dy <= cellRadius; ++dy)
		{
			for (int dx = -cellRadius; dx <= cellRadius; ++dx)
			{
				localCellsSearched++;

				int3 neighborCell = centerCell + int3(dx, dy, dz);
				uint cellID = GetMortonCellIDFromCellCoord_Attach(neighborCell);
				uint bCellStart = BoundaryCellStart[cellID];
				uint bCellEnd = BoundaryCellEnd[cellID];

				// Skip empty cells
				if (bCellStart == INVALID_INDEX || bCellEnd == INVALID_INDEX) continue;

				localNonEmptyCells++;

				// Check boundary particles in this cell
				uint maxBoundaryIdx = min(bCellEnd, (uint)(BoundaryParticleCount - 1));
				for (uint bi = bCellStart; bi <= maxBoundaryIdx; ++bi)
				{
					localBoundaryChecked++;

					FGPUBoundaryParticle boundary = SortedBoundaryParticles[bi];
					float3 diff = pos - boundary.Position;
					float distSq = dot(diff, diff);

					// Track minimum distance
					if (distSq < localMinDistSq)
					{
						localMinDistSq = distSq;
					}

					// Track first OwnerID seen
					if (localFirstOwnerID == -999)
					{
						localFirstOwnerID = boundary.OwnerID;
					}

					// Count OwnerID == -1
					if (boundary.OwnerID == -1)
					{
						localOwnerNegOne++;
					}

					// Debug: separate checks
					if (distSq < nearestDistSq)
					{
						localWithinRadius++;

						// Debug: Check each condition separately
						bool bOwnerGEZero = (boundary.OwnerID >= 0);
						bool bOwnerLEMax = (boundary.OwnerID <= MaxOwnerID);

						if (bOwnerGEZero && bOwnerLEMax)
						{
							localValidOwner++;
							nearestDistSq = distSq;
							nearestIdx = (int)bi;
							nearestOwnerID = boundary.OwnerID;
							nearestBoneIndex = boundary.BoneIndex;
							nearestNormal = boundary.Normal;
							nearestVelocity = boundary.Velocity;
						}
					}
				}
			}
		}
	}

	// Debug: Update counters
	uint dummy;
	InterlockedAdd(AttachmentCounter[8], localCellsSearched, dummy);
	InterlockedAdd(AttachmentCounter[9], localNonEmptyCells, dummy);
	InterlockedAdd(AttachmentCounter[10], localBoundaryChecked, dummy);
	InterlockedAdd(AttachmentCounter[11], localWithinRadius, dummy);
	InterlockedAdd(AttachmentCounter[12], localValidOwner, dummy);
	InterlockedAdd(AttachmentCounter[15], localOwnerNegOne, dummy);

	// Store min distance (convert float to uint bits for atomic min)
	// We'll use InterlockedMin on the uint representation
	uint minDistBits = asuint(localMinDistSq);
	InterlockedMin(AttachmentCounter[13], minDistBits, dummy);

	// Store first OwnerID found (only first thread to write)
	if (localFirstOwnerID != -999)
	{
		InterlockedCompareExchange(AttachmentCounter[14], 0xFFFFFFFF, (uint)localFirstOwnerID, dummy);
	}

	outDistance = sqrt(nearestDistSq);
	outOwnerID = nearestOwnerID;
	outBoneIndex = nearestBoneIndex;
	outWorldNormal = nearestNormal;
	outBoundaryVelocity = nearestVelocity;
	return nearestIdx;
}

//=============================================================================
// Helper: Get transform matrix for a given bone or fallback to component transform
// Returns the appropriate transform matrix based on BoneIndex
//=============================================================================

float4x4 GetBoneOrComponentTransform(int boneIndex, int ownerID)
{
	if (boneIndex >= 0 && boneIndex < BoneCount)
	{
		// Use bone transform for skeletal mesh
		return BoneTransforms[boneIndex];
	}
	else if (ownerID >= 0 && ownerID <= MaxOwnerID)
	{
		// Fallback to component transform for static mesh or invalid bone
		return OwnerTransforms[ownerID].WorldMatrix;
	}
	// Identity matrix as last resort
	return float4x4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	);
}

float4x4 GetBoneOrComponentInverseTransform(int boneIndex, int ownerID)
{
	if (boneIndex >= 0 && boneIndex < BoneCount)
	{
		// Use pre-computed inverse from CPU (handles scale correctly)
		// transpose(rotation) = inverse(rotation) is ONLY valid for orthonormal matrices (scale=1)
		// Unreal bone transforms often include scale, so we must use proper matrix inverse
		return InverseBoneTransforms[boneIndex];
	}
	else if (ownerID >= 0 && ownerID <= MaxOwnerID)
	{
		// Fallback to component inverse transform
		return OwnerTransforms[ownerID].InverseWorldMatrix;
	}
	// Identity matrix as last resort
	return float4x4(
		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1
	);
}

//=============================================================================
// Main Compute Shader: Boundary Attachment Update
// Handles Attach, Detach, and position constraint for attached particles
// Uses Bone-local position for stable attachment (follows bone animation)
//
// IMPORTANT: Position update MUST happen BEFORE distance check!
// Otherwise, when bone moves, the particle appears far away and gets detached.
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void BoundaryAttachmentUpdateCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
	uint idx = DispatchThreadId.x;
	if (idx >= (uint)ParticleCount)
	{
		return;
	}

	// Skip if no boundary particles
	if (BoundaryParticleCount <= 0)
	{
		return;
	}

	FGPUFluidParticle particle = Particles[idx];

	// Attachment data is now embedded in particle (no separate buffer needed)
	// This ensures correct behavior during Z-Order sorting
	bool bCurrentlyAttached = HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED);
	uint dummy;

	//=========================================================================
	// STEP 1: Find nearest boundary particle (needed for bone velocity)
	//=========================================================================
	float foundDistance;
	int foundOwnerID;
	int foundBoneIndex;
	float3 foundWorldNormal;
	float3 foundBoundaryVelocity;
	int nearestBoundaryIdx = FindNearestBoundaryParticle(particle.Position, foundDistance, foundOwnerID, foundBoneIndex, foundWorldNormal, foundBoundaryVelocity);

	// Debug: Track search results
	if (nearestBoundaryIdx >= 0)
	{
		InterlockedAdd(AttachmentCounter[1], 1, dummy);  // Found a boundary

		if (foundDistance <= AttachRadius)
		{
			InterlockedAdd(AttachmentCounter[2], 1, dummy);  // Within radius
		}
	}

	//=========================================================================
	// STEP 2: Attached particles - Apply bone delta (teleport to follow character)
	//
	// Key concept:
	// - Physics (Adhesion, gravity, viscosity) is already applied in other passes
	// - Attach tag ONLY handles: character movement → particle follows
	// - If character moves too fast → detach
	// - All other physics remains unchanged
	//=========================================================================
	bool bDetachedThisFrame = false;

	if (bCurrentlyAttached && particle.AttachOwnerID >= 0 && particle.AttachOwnerID <= MaxOwnerID)
	{
		// Get bone velocity from nearest boundary particle
		// This represents how fast the character/bone is moving
		float3 boneVelocity = foundBoundaryVelocity;
		float3 boneDelta = boneVelocity * DeltaTime;
		float boneSpeed = length(boneVelocity);  // cm/s

		// Detach threshold: if character moves too fast, particle can't keep up
		// DetachSpeedThreshold is in cm/s (set in editor)
		if (boneSpeed > DetachSpeedThreshold)
		{
			// Character moved too fast → DETACH
			particle.AttachOwnerID = -1;
			particle.AttachBoneIndex = -1;
			particle.AttachLocalPosition = float3(0.0f, 0.0f, 0.0f);
			particle.AttachLocalDistance = 0.0f;

			particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED);
			particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);
			particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_ATTACH_COOLDOWN);
			particle.AttachmentTime = CurrentTime;

			bDetachedThisFrame = true;
			bCurrentlyAttached = false;

			InterlockedAdd(AttachmentCounter[5], 1, dummy);  // Detachments
		}
		else
		{
			// Apply bone delta: teleport particle to follow character movement
			// Physics already applied, this just adds the character movement on top
			particle.Position += boneDelta;
			particle.PredictedPosition += boneDelta;
		}
	}

	//=========================================================================
	// STEP 3: Update attachment info based on nearest boundary
	//
	// After physics moves the particle, find the nearest boundary and:
	// - If within AttachRadius: update OwnerID/BoneIndex/LocalPosition
	// - If outside AttachRadius * DetachDistanceMultiplier: detach
	//
	// This allows particles to "slide" between bones while staying attached
	//=========================================================================
	bool bWithinAttachRadius = (nearestBoundaryIdx >= 0) &&
	                           (foundDistance <= AttachRadius) &&
	                           (foundOwnerID >= 0) &&
	                           (foundOwnerID <= MaxOwnerID);

	if (bWithinAttachRadius)
	{
		//=====================================================================
		// WITHIN ATTACH RADIUS: Attach or update attachment
		//=====================================================================

		if (!bCurrentlyAttached)
		{
			//=== CHECK COOLDOWN ===
			bool bInCooldown = HasFlag(particle.Flags, GPU_PARTICLE_FLAG_ATTACH_COOLDOWN);

			if (bInCooldown)
			{
				// Check if cooldown has expired
				float timeSinceDetach = CurrentTime - particle.AttachmentTime;
				if (timeSinceDetach >= AttachCooldown)
				{
					// Cooldown expired, clear flag
					particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_ATTACH_COOLDOWN);
					particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);
					bInCooldown = false;
				}
				else
				{
					// Still in cooldown, count it
					InterlockedAdd(AttachmentCounter[6], 1, dummy);  // In cooldown
				}
			}

			if (!bInCooldown)
			{
				//=== NEW ATTACH ===
				// Convert particle world position to bone's local space
				float4x4 invTransform = GetBoneOrComponentInverseTransform(foundBoneIndex, foundOwnerID);
				float3 localPos = InverseTransformPosition(particle.Position, invTransform);

				particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED);

				// Store attachment data in particle (embedded)
				particle.AttachOwnerID = foundOwnerID;
				particle.AttachBoneIndex = foundBoneIndex;
				particle.AttachmentTime = CurrentTime;
				particle.AttachLocalPosition = localPos;
				particle.AttachLocalDistance = foundDistance;

				InterlockedAdd(AttachmentCounter[4], 1, dummy);  // New attachment
			}
		}
		else if (!bDetachedThisFrame)
		{
			//=== UPDATE ATTACHMENT ===
			// Particle is already attached, update to nearest boundary
			// This allows sliding between bones while staying attached
			float4x4 invTransform = GetBoneOrComponentInverseTransform(foundBoneIndex, foundOwnerID);
			float3 localPos = InverseTransformPosition(particle.Position, invTransform);

			// Update attachment info to current nearest boundary
			particle.AttachOwnerID = foundOwnerID;
			particle.AttachBoneIndex = foundBoneIndex;
			particle.AttachLocalPosition = localPos;
			particle.AttachLocalDistance = foundDistance;

			InterlockedAdd(AttachmentCounter[7], 1, dummy);  // Maintained
		}
	}
	else if (bCurrentlyAttached && !bDetachedThisFrame)
	{
		//=====================================================================
		// ATTACHED BUT OUTSIDE ATTACH RADIUS: Check detach threshold
		//=====================================================================
		float detachThreshold = AttachRadius * DetachDistanceMultiplier;

		if (foundDistance > detachThreshold || nearestBoundaryIdx < 0)
		{
			// DETACH: Particle slid too far from any boundary
			particle.AttachOwnerID = -1;
			particle.AttachBoneIndex = -1;
			particle.AttachLocalPosition = float3(0.0f, 0.0f, 0.0f);
			particle.AttachLocalDistance = 0.0f;

			particle.Flags = ClearFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED);
			particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_JUST_DETACHED);
			particle.Flags = SetFlag(particle.Flags, GPU_PARTICLE_FLAG_ATTACH_COOLDOWN);
			particle.AttachmentTime = CurrentTime;

			bDetachedThisFrame = true;

			InterlockedAdd(AttachmentCounter[5], 1, dummy);  // Detachments
		}
		else
		{
			// Between AttachRadius and detachThreshold - update attachment info
			// Still attached, just outside preferred radius
			float4x4 invTransform = GetBoneOrComponentInverseTransform(foundBoneIndex, foundOwnerID);
			float3 localPos = InverseTransformPosition(particle.Position, invTransform);

			particle.AttachOwnerID = foundOwnerID;
			particle.AttachBoneIndex = foundBoneIndex;
			particle.AttachLocalPosition = localPos;
			particle.AttachLocalDistance = foundDistance;

			InterlockedAdd(AttachmentCounter[7], 1, dummy);  // Maintained
		}
	}

	// Write back (particle includes embedded attachment data)
	Particles[idx] = particle;

	// Debug: Count attached particles
	if (HasFlag(particle.Flags, GPU_PARTICLE_FLAG_IS_BOUNDARY_ATTACHED))
	{
		InterlockedAdd(AttachmentCounter[0], 1, dummy);
	}

	// Debug: Store MaxOwnerID value from shader (once, thread 0)
	if (idx == 0)
	{
		AttachmentCounter[16] = (uint)MaxOwnerID;
		AttachmentCounter[17] = (uint)BoneCount;
	}
}
