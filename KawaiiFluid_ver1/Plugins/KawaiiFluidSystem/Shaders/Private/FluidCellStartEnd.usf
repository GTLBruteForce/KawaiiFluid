// Copyright KawaiiFluid Team. All Rights Reserved.
// GPU Fluid Physics - Cell Start/End Index Computation
//
// After particles are sorted by Morton code, this shader computes the
// start and end indices for each cell in the sorted array.
//
// Because particles are sorted, all particles in the same cell are contiguous.
// We only need to find where each cell begins and ends.
//
// Neighbor lookup becomes: for (i = CellStart[cellID]; i <= CellEnd[cellID]; i++)
// This is much faster than hash table linked-list traversal.

#include "/Engine/Public/Platform.ush"
#include "/Engine/Private/Common.ush"

//=============================================================================
// Configuration
//=============================================================================

// Maximum number of cells (must match SPATIAL_HASH_SIZE or Morton code resolution)
#ifndef MAX_CELLS
#define MAX_CELLS 65536  // 2^16 cells (64K)
#endif

// Invalid index marker (no particles in cell)
#define INVALID_INDEX 0xFFFFFFFF

//=============================================================================
// Shader Parameters
//=============================================================================

// Input: Sorted Morton codes (keys from radix sort)
StructuredBuffer<uint> SortedMortonCodes;

// Output: Cell start and end indices
RWStructuredBuffer<uint> CellStart;  // CellStart[cellID] = first particle index
RWStructuredBuffer<uint> CellEnd;    // CellEnd[cellID] = last particle index

int ParticleCount;

//=============================================================================
// Clear Cell Indices
// Initialize all cells to invalid (no particles)
//=============================================================================

#define THREAD_GROUP_SIZE 256

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ClearCellIndicesCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint cellIdx = DispatchThreadId.x;
    if (cellIdx >= MAX_CELLS)
    {
        return;
    }

    CellStart[cellIdx] = INVALID_INDEX;
    CellEnd[cellIdx] = INVALID_INDEX;
}

//=============================================================================
// Compute Cell Start/End Indices
// Detects boundaries where Morton code changes in sorted array
//=============================================================================

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeCellStartEndCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    uint currentCode = SortedMortonCodes[idx];

    // Map Morton code to cell ID (could be direct mapping or hash)
    // For now, use modulo to fit into cell array size
    uint cellID = currentCode & (MAX_CELLS - 1);

    // Check if this is the first particle or Morton code changed
    if (idx == 0)
    {
        // First particle always starts a cell
        CellStart[cellID] = idx;
    }
    else
    {
        uint prevCode = SortedMortonCodes[idx - 1];
        uint prevCellID = prevCode & (MAX_CELLS - 1);

        if (cellID != prevCellID)
        {
            // New cell starts here
            CellStart[cellID] = idx;
            // Previous cell ends at idx - 1
            CellEnd[prevCellID] = idx - 1;
        }
    }

    // Check if this is the last particle
    if (idx == (uint)(ParticleCount - 1))
    {
        // Last particle always ends its cell
        CellEnd[cellID] = idx;
    }
}

//=============================================================================
// Alternative: Direct Morton Code Cell Lookup
// Uses full Morton code as cell ID (no hashing/modulo)
// Requires larger cell arrays but avoids collisions
//=============================================================================

// For this version, MAX_CELLS should be large enough to hold all Morton codes
// 10-bit per axis = 2^30 possible codes, too large for direct indexing
// So we use upper bits as cell ID

#define MORTON_CELL_BITS 16  // Use upper 16 bits of Morton code as cell ID

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeCellStartEndMortonCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    uint currentCode = SortedMortonCodes[idx];
    uint cellID = currentCode >> (30 - MORTON_CELL_BITS);  // Upper bits

    if (idx == 0)
    {
        CellStart[cellID] = idx;
    }
    else
    {
        uint prevCode = SortedMortonCodes[idx - 1];
        uint prevCellID = prevCode >> (30 - MORTON_CELL_BITS);

        if (cellID != prevCellID)
        {
            CellStart[cellID] = idx;
            CellEnd[prevCellID] = idx - 1;
        }
    }

    if (idx == (uint)(ParticleCount - 1))
    {
        CellEnd[cellID] = idx;
    }
}

//=============================================================================
// Hybrid: Cell-Based with Grid Coordinates
// Uses actual grid cell coordinates instead of Morton code
// Better for SPH where we iterate 27 neighboring cells
//=============================================================================

// Input: Sorted cell IDs (computed from position, not Morton code)
StructuredBuffer<uint> SortedCellIDs;

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ComputeCellStartEndGridCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint idx = DispatchThreadId.x;
    if (idx >= (uint)ParticleCount)
    {
        return;
    }

    uint currentCellID = SortedCellIDs[idx];

    // Handle wrap-around for hash-based cell IDs
    uint cellIdx = currentCellID & (MAX_CELLS - 1);

    if (idx == 0)
    {
        CellStart[cellIdx] = idx;
    }
    else
    {
        uint prevCellID = SortedCellIDs[idx - 1];
        uint prevCellIdx = prevCellID & (MAX_CELLS - 1);

        if (currentCellID != prevCellID)
        {
            CellStart[cellIdx] = idx;
            CellEnd[prevCellIdx] = idx - 1;
        }
    }

    if (idx == (uint)(ParticleCount - 1))
    {
        CellEnd[cellIdx] = idx;
    }
}

//=============================================================================
// Validation: Count particles per cell (for debugging)
//=============================================================================

RWStructuredBuffer<uint> CellCounts;  // For validation

[numthreads(THREAD_GROUP_SIZE, 1, 1)]
void ValidateCellCountsCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint cellIdx = DispatchThreadId.x;
    if (cellIdx >= MAX_CELLS)
    {
        return;
    }

    uint start = CellStart[cellIdx];
    uint end = CellEnd[cellIdx];

    if (start == INVALID_INDEX || end == INVALID_INDEX)
    {
        CellCounts[cellIdx] = 0;
    }
    else
    {
        CellCounts[cellIdx] = end - start + 1;
    }
}
