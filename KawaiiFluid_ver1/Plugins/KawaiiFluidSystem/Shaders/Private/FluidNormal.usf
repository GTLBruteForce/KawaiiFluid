// Copyright KawaiiFluid Team. All Rights Reserved.

#include "/Engine/Private/Common.ush"
#include "FluidCommon.ush"

// IO
Texture2D<float> InputDepthTexture;
RWTexture2D<float4> OutputNormalTexture;

float2 TextureSize;
float2 InverseTextureSize;

float4x4 ProjectionMatrix;
float4x4 InverseProjectionMatrix;

// 배경 기준
#define BACKGROUND_DEPTH_THRESH 3.0e30f

// Lenear Depth를 활용하여 View Space Position 위치 재구성
float3 ReconstructViewPositionFromLinearDepth(float2 ScreenUV, float LinearDepth)
{
    // Clip Space 좌표 (Z는 방향만 구할 것이므로 0.5나 1.0 아무거나 상관없음)
    float4 ClipPosition = float4(ScreenUV * 2.0 - 1.0, 0.5, 1.0);

    // View Space로 역투영
    float4 ViewPosition = mul(ClipPosition, InverseProjectionMatrix);
    ViewPosition /= ViewPosition.w;

    // 방향 벡터 추출 (View Space 원점 기준)
    // Z가 1.0이 되도록 정규화 (View Space Z축 기준 평면)
    float3 ViewRay = ViewPosition.xyz / ViewPosition.z;

    // 실제 깊이를 곱해서 위치 확정
    // LinearDepth는 양수 거리로 저장되어 있으므로, 음수로 변환하여 View Space Z 복원
    return ViewRay * (-LinearDepth);
}

[numthreads(8, 8, 1)]
void ReconstructNormalCS(uint3 DispatchThreadId : SV_DispatchThreadID)
{
    uint2 PixelPosition = DispatchThreadId.xy;
    if (PixelPosition.x >= (uint)TextureSize.x || PixelPosition.y >= (uint)TextureSize.y)
    {
        return;
    }

    float CenterDepth = InputDepthTexture.Load(int3(PixelPosition, 0));

    // 배경 체크
    if (CenterDepth > BACKGROUND_DEPTH_THRESH)
    {
        OutputNormalTexture[PixelPosition] = float4(0, 0, 0, 0);
        return;
    }

    // UV 계산
    float2 UV = (float2(PixelPosition) + 0.5) * InverseTextureSize;

    // 인접 픽셀 좌표 (Clamp 처리)
    int2 RightPosition = min(PixelPosition + int2(1, 0), int2(TextureSize) - 1);
    int2 BottomPosition = min(PixelPosition + int2(0, 1), int2(TextureSize) - 1);

    // 인접 Depth Load
    float DepthRight = InputDepthTexture.Load(int3(RightPosition, 0));
    float DepthBottom = InputDepthTexture.Load(int3(BottomPosition, 0));
    
    // View Position 재구성
    float3 PositionCenter = ReconstructViewPositionFromLinearDepth(UV, CenterDepth);
    float3 PositionRight, PositionBottom;

    // 배경에 접한 외곽선에서 Normal 문제를 방지하기 위한 방어 코드
    if (DepthRight > BACKGROUND_DEPTH_THRESH) 
    {
        PositionRight = PositionCenter; 
    }
    else 
    {
        float2 UVRight = (float2(RightPosition) + 0.5) * InverseTextureSize;
        PositionRight = ReconstructViewPositionFromLinearDepth(UVRight, DepthRight);
    }
    
    // 배경에 접한 외곽선에서 Normal 문제를 방지하기 위한 방어 코드
    if (DepthBottom > BACKGROUND_DEPTH_THRESH)
    {
        PositionBottom = PositionCenter;
    }
    else
    {
        float2 UVBottom = (float2(BottomPosition) + 0.5) * InverseTextureSize;
        PositionBottom = ReconstructViewPositionFromLinearDepth(UVBottom, DepthBottom);
    }
    
    // 미분 연산
    float3 ddx = PositionRight - PositionCenter;
    float3 ddy = PositionBottom - PositionCenter;

    // Normal 계산
    float3 Normal = normalize(cross(ddx, ddy));

    // 올바른 방향으로 노멀 반전
    if (Normal.z > 0.0)
    {
        Normal = -Normal;
    }

    // 저장
    OutputNormalTexture[PixelPosition] = float4(Normal, 1.0);
}
